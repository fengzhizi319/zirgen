#[picus_analyze]
component ShaNextBlockCycle(back1: TopState) {
  Log("ShaNextBlockCycle");
  // Extract current a + e values in packed format
  cur_a := for i : 0..4 { Pack32(for j : 0..32 { back1.bits[256 - (i + 1)*32 + j] })};
  cur_e := for i : 0..4 { Pack32(for j : 0..32 { back1.bits[512 - (i + 1)*32 + j] })};
  // Get the same from the store sflat state
  prev_a := for i : 0..4 { for j : 0..2 { back1.sflat[i*2 + j] }};
  prev_e := for i : 0..4 { for j : 0..2 { back1.sflat[8 + i*2 + j] }};
  // Add + store
  tot_a := for i : 0..4 { CarryAndExpand(Add2(cur_a[i], prev_a[i])) };
  tot_e := for i : 0..4 { CarryAndExpand(Add2(cur_e[i], prev_e[i])) };
}

component TopState(bits: Array<Val, 800>, kflat: Array<Val, 100>, sflat: Array<Val, 16>) {
  public bits := for i : 0..800 {
    Reg(bits[i])
  };
  // Log("Top State Top 16 bits = %x", Pack<16, 16>(for i : 0..16 { bits[i] })[0]);
  public kflat := for i : 0..100 {
    Reg(kflat[i])
  };
  public sflat := for i : 0..16 {
    Reg(sflat[i])
  };
}

component Pack<N: Val, P: Val>(in : Array<Val, N>) {
  N % P = 0;
  for i : 0..(N / P) {
    reduce for j : 0..P { Po2(j) * in[i*P+ j] } init 0 with Add
  }
}

component Pack32(x: Array<Val, 32>) { Pack<32, 16>(x) }

component Add2(a: Array<Val, 2>, b: Array<Val, 2>) {
  for i : 0..2 { a[i] + b[i] }
}

component CarryExtract(in: Val) {
  bit0 := NondetBitReg(((in & 0xf0000) / 0x10000) & 1);
  bit1 := NondetBitReg((((in & 0xf0000) / 0x10000) & 2) / 2);
  bit2 := NondetBitReg((((in & 0xf0000) / 0x10000) & 4) / 4);
  public carry := bit2 * 4 + bit1 * 2 + bit0;
  public out := in - carry * 0x10000;
}

component CarryAndExpand(in: Array<Val, 2>) {
  lowCarry := CarryExtract(in[0]);
  highCarry := CarryExtract(in[1] + lowCarry.carry);
  out := UnpackReg<32, 16>([lowCarry.out, highCarry.out]);
  out
}

component UnpackReg<N: Val, P: Val>(in: Array<Val, N/P>) {
  bitVals := UnpackNondet<N, P>(in);
  bits := for n : 0..N { NondetBitReg(bitVals[n]) };
  EqArr<N/P>(Pack<N, P>(bits), in);
  bits
}

component Po2(n: Val) {
  arr := [ 0x00000001, 0x00000002, 0x00000004, 0x00000008,
           0x00000010, 0x00000020, 0x00000040, 0x00000080,
           0x00000100, 0x00000200, 0x00000400, 0x00000800,
           0x00001000, 0x00002000, 0x00004000, 0x00008000,
           0x00010000, 0x00020000, 0x00040000, 0x00080000,
           0x00100000, 0x00200000, 0x00400000, 0x00800000,
           0x01000000, 0x02000000, 0x04000000, 0x08000000,
           0x10000000, 0x20000000
  ];
  arr[n]
}

component NondetBitReg(val: Val) {
  reg := NondetReg(val);
  AssertBit(reg);
  reg
}

function AssertBit(val: Val) {
  val * (1 - val) = 0;
}

component UnpackNondet<N: Val, P: Val>(in: Array<Val, N/P>) {
  N % P = 0;
  inv := Inv(P);
  for n : 0..N {
    j := n % P;
    i := (n - j) * inv;
    (in[i] & Po2(j)) / Po2(j)
  }
}

component EqArr<SIZE: Val>(a: Array<Val, SIZE>, b: Array<Val, SIZE>) {
  for i : 0..SIZE {
    a[i] = b[i];
  }
}
