

import keccack;
import sha2;

component TopState(bits: Array<Val, 800>, kflat: Array<Val, 100>, sflat: Array<Val, 16>) {
  bits := for i : 0..800 {
    Reg(bits[i])
  };
  kflat := for i : 0..100 {
    Reg(kflat[i])
  };
  sflat := for i : 0..16 {
    Reg(sflat[i])
  };
}

// Convert state to 2 arrays of 800 bit each
component FlattenKeccack(a: Array<Array<Array<Val, 64>, 5>, 5>) {
  for kh : 0..2 {
    for y : 0..800 {
      kl := y & 31;
      ij := (y - kl) / 32;
      j := ij % 5;
      i := (ij - j) / 5;
      a[i + 0][j + 0][kh * 32 + kl]
    }
  }
}

// Convert back to 5x5x64
component ExpandKeccack(a: Array<Array<Val, 800>, 2>) {
  for i : 0..5 {
    for j : 0..5 {
      for k : 0..64 {
        kl := k & 31;
        kh := (k - kl) / 32;
        a[kh + 0][i*5*32 + j*32 + kl]
      }
    }
  }
}

component FlattenThetaB(b: Array<Array<Val, 64>, 5>) {
  for x : 0..800 {
    if (InRange(0, x, 5 * 64)) {
      k := x & 63;
      j := (x - k) / 64;
      b[j + 0][k]
    } else {
      0
    }
  }
}

component ExpandThetaB(b: Array<Val, 800>) {
  for j : 0..5 {
    for k : 0..64 {
      b[j * 64 + k]
    }
  }
}

// 5 cycles for 1 round of Keccack (ThetaP1, 2x Pi-Rho-ThetaP2, 2x Iota-Chi)
component KeccackRound0(s0: TopState, s1: TopState) {
  a := ExpandKeccack([s0.bits, s1.bits]);
  b := ThetaP1(a);
  top := TopState(FlattenThetaB(b), s1.kflat, s1.sflat);
  for j : 0..5 {
    for k : 0..64 {
      AliasLayout!(top.bits[j*64 + k], b[j][k]);
    }
  };
  top
}

component KeccackRound12<IDX: Val>(sb: TopState, s0: TopState, s1: TopState, back1: TopState) {
  a := ExpandKeccack([s0.bits, s1.bits]);
  b := ExpandThetaB(sb.bits);
  TopState(FlattenKeccack(Pi(Rho(ThetaP2(a, b))))[IDX], back1.kflat, back1.sflat)
}

component KeccackRound34<IDX: Val>(s0: TopState, s1: TopState, back1: TopState, round: Val) {
  a := ExpandKeccack([s0.bits, s1.bits]);
  TopState(FlattenKeccack(Iota(Chi(a), round))[IDX], back1.kflat, back1.sflat)
}

// Get K in groups of 8 
component GetK8(oneHot: OneHot<8>) {
  table := TableK();
  for i : 0..8 { 
    for j : 0..2 {
      reduce for r : 0..8 { oneHot[r] * table[r*8 + i][j] } init 0 with Add
    }
  }
}

component ShaState(a: Array<Array<Val, 32>, 4>, e: Array<Array<Val, 32>, 4>, w: Array<Array<Val, 32>, 16>) {
  a := a;
  e := e;
  w := w;
}

component DoShaStep(in: ShaState, k: Array<Val, 2>, doLoad: Val, win: Array<Val, 2>) {
  rawW := ComputeW(in.w);
  pickW := for i : 0..2 { doLoad * win[i] + (1 - doLoad) * rawW[i] };
  w := CarryAndExpand(pickW);
  comp := ComputeAE(in.a, in.e, w, k);
  a := CarryAndExpand(comp.rawA);
  e := CarryAndExpand(comp.rawE);
  newState := ShaState(PushFront<4>(a, in.a), PushFront<4>(e, in.e), PushFront<16>(w, in.w));
}

component LoadShaState(back1: TopState, back2: TopState) {
  a := for i : 0..4 { for j : 0..32 { back1.bits[256 - (i + 1)*32 + j] }};
  e := for i : 0..4 { for j : 0..32 { back1.bits[512 - (i + 1)*32 + j] }};
  w := for i : 0..16 { 
    if (InRange(0, i, 8)) {
      for j : 0..32 { back1.bits[768 - (i + 1)*32 + j] }
    } else {
      for j : 0..32 { back2.bits[768 - (i - 8 + 1)*32 + j] }
    }
  };
  ShaState(a, e, w)
}

component ExtractBits(steps: Array<DoShaStep, 8>, i: Val) {
    [InRange(0, i, 8), InRange(8, i, 16), InRange(16, i, 24), InRange(24, i, 25)] ->
      (steps[i].w, steps[i - 8].a, steps[i - 16].e, for j : 0..32 {0})
}

component LoadWin(kf: Array<Val, 100>, round: Val, block: Val) {
  blockSelect := OneHot<4>(block);
  [1 - round, round] -> (
    blockSelect -> (
      for i : 0..8 { for j : 0..2 { kf[(i + 0) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { kf[(i + 16) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { kf[(i + 32) * 2 + j] }},
      [[kf[96], kf[97]], [kf[98], kf[99]], [0, 0], [0, 0],
       [0, 0], [0, 0], [0, 0], [0, 0]]
    ),
    blockSelect -> (
      for i : 0..8 { for j : 0..2 { kf[(i + 8) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { kf[(i + 24) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { kf[(i + 40) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { 0 }}
    )
  )
}

component ShaCycle(back1: TopState, back2: TopState, round: Val, block: Val) {
  // Extract SHA state
  stateIn := LoadShaState(back1, back2);
  oneHot := OneHot<8>(round);
  isLoad := Reg(oneHot -> (1, 1, 0, 0, 0, 0, 0, 0));
  localK := GetK8(oneHot);
  win := LoadWin(back1.kflat, round, block);
  step0 := DoShaStep(stateIn, localK[0], isLoad, win[0]);
  step1 := DoShaStep(step0.newState, localK[1], isLoad, win[1]);
  step2 := DoShaStep(step1.newState, localK[2], isLoad, win[2]);
  step3 := DoShaStep(step2.newState, localK[3], isLoad, win[3]);
  step4 := DoShaStep(step3.newState, localK[4], isLoad, win[4]);
  step5 := DoShaStep(step4.newState, localK[5], isLoad, win[5]);
  step6 := DoShaStep(step5.newState, localK[6], isLoad, win[6]);
  step7 := DoShaStep(step6.newState, localK[7], isLoad, win[7]);
  steps := [step0, step1, step2, step3, step4, step5, step6, step7];
  bits := for x : 0..800 {
    j := x & 31;
    i := (x - j) / 32 + 0;
    ExtractBits(steps, i)[j]
  };
  topState := TopState(bits, back1.kflat, back1.sflat);
  for i : 0..8 {
    for j : 0..32 {
      AliasLayout!(steps[i].w[j], topState.bits[i*32 + j]);
      AliasLayout!(steps[i].a[j], topState.bits[256 + i*32 + j]);
      AliasLayout!(steps[i].e[j], topState.bits[512 + i*32 + j]);
    }
  };
  topState
}

extern GetPreimage(idx: Val): Val;

component ReadCycle(stateIn: TopState) {
  load := for i : 0..100 { NondetReg(GetPreimage(i)) };
  bits := for i : 0..800 { 0 };  // TODO: load from sflat
  stateOut := TopState(bits, load, stateIn.sflat);
  for i : 0..100 {
    AliasLayout!(stateOut.kflat[i], load[i]);
  };
  stateOut
}

extern GetCycleType(): Val;
extern GetRound(): Val;
extern GetBlock(): Val;

component Top() {
  cycleType := NondetReg(GetCycleType());
  round := NondetReg(GetRound());
  block := NondetReg(GetBlock());
  cycleMux := OneHot<7>(cycleType);
  curState: TopState;
  curState := cycleMux -> (
    ReadCycle(curState@1),
    KeccackRound0(curState@2, curState@1),
    KeccackRound12<0>(curState@3, curState@2, curState@1, curState@1),
    KeccackRound12<1>(curState@4, curState@3, curState@2, curState@1),
    KeccackRound34<0>(curState@2, curState@1, curState@1, round),
    KeccackRound34<1>(curState@3, curState@2, curState@1, round),
    ShaCycle(curState@1, curState@2, round, block)
  );
}
