
import is_zero;
import keccak;
import sha2;

component TopState(bits: Array<Val, 800>, kflat: Array<Val, 100>, sflat: Array<Val, 16>) {
  bits := for i : 0..800 {
    Reg(bits[i])
  };
  Log("Top State Top 16 bits = %x", Pack<16, 16>(for i : 0..16 { bits[i] })[0]); 
  kflat := for i : 0..100 {
    Reg(kflat[i])
  };
  sflat := for i : 0..16 {
    Reg(sflat[i])
  };
}

// Convert state to 2 arrays of 800 bit each
component FlattenKeccak(a: Array<Array<Array<Val, 64>, 5>, 5>) {
  for kh : 0..2 {
    for y : 0..800 {
      kl := y & 31;
      ij := (y - kl) / 32;
      j := ij % 5;
      i := (ij - j) / 5;
      a[i + 0][j + 0][kh * 32 + kl]
    }
  }
}

// Convert back to 5x5x64
component ExpandKeccak(a: Array<Array<Val, 800>, 2>) {
  for i : 0..5 {
    for j : 0..5 {
      for k : 0..64 {
        kl := k & 31;
        kh := (k - kl) / 32;
        a[kh + 0][i*5*32 + j*32 + kl]
      }
    }
  }
}

component FlattenThetaB(b: Array<Array<Val, 64>, 5>) {
  for x : 0..800 {
    if (InRange(0, x, 5 * 64)) {
      k := x & 63;
      j := (x - k) / 64;
      b[j + 0][k]
    } else {
      0
    }
  }
}

component ExpandThetaB(b: Array<Val, 800>) {
  for j : 0..5 {
    for k : 0..64 {
      b[j * 64 + k]
    }
  }
}

// 5 cycles for 1 round of Keccak (ThetaP1, 2x Pi-Rho-ThetaP2, 2x Iota-Chi)
component KeccakRound0(s0: TopState, s1: TopState) {
  Log("KeccakRound0");
  a := ExpandKeccak([s0.bits, s1.bits]);
  b := ThetaP1(a);
  top := TopState(FlattenThetaB(b), s1.kflat, s1.sflat);
  for j : 0..5 {
    for k : 0..64 {
      AliasLayout!(top.bits[j*64 + k], b[j][k]);
    }
  };
  top
}

component KeccakRound12<IDX: Val>(sb: TopState, s0: TopState, s1: TopState, back1: TopState) {
  Log("KeccakRound12");
  a := ExpandKeccak([s0.bits, s1.bits]);
  b := ExpandThetaB(sb.bits);
  TopState(FlattenKeccak(Pi(Rho(ThetaP2(a, b))))[IDX], back1.kflat, back1.sflat)
}

component KeccakRound34<IDX: Val>(s0: TopState, s1: TopState, back1: TopState, round: Val) {
  Log("KeccakRound34", round);
  a := ExpandKeccak([s0.bits, s1.bits]);
  TopState(FlattenKeccak(Iota(Chi(a), round))[IDX], back1.kflat, back1.sflat)
}

// Get K in groups of 8 
component GetK8(oneHot: OneHot<8>) {
  table := TableK();
  for i : 0..8 { 
    for j : 0..2 {
      reduce for r : 0..8 { oneHot[r] * table[r*8 + i][j] } init 0 with Add
    }
  }
}

component ShaState(a: Array<Array<Val, 32>, 4>, e: Array<Array<Val, 32>, 4>, w: Array<Array<Val, 32>, 16>) {
  a := a;
  e := e;
  w := w;
}

component DoShaStep(in: ShaState, k: Array<Val, 2>, doLoad: Val, win: Array<Val, 2>) {
  rawW := ComputeW(in.w);
  pickW := for i : 0..2 { doLoad * win[i] + (1 - doLoad) * rawW[i] };
  w := CarryAndExpand(pickW);
  comp := ComputeAE(in.a, in.e, w, k);
  a := CarryAndExpand(comp.rawA);
  e := CarryAndExpand(comp.rawE);
  newState := ShaState(PushFront<4>(a, in.a), PushFront<4>(e, in.e), PushFront<16>(w, in.w));
}

component LoadShaState(back1: TopState, back2: TopState) {
  a := for i : 0..4 { for j : 0..32 { back1.bits[256 - (i + 1)*32 + j] }};
  e := for i : 0..4 { for j : 0..32 { back1.bits[512 - (i + 1)*32 + j] }};
  w := for i : 0..16 { 
    if (InRange(0, i, 8)) {
      for j : 0..32 { back1.bits[768 - (i + 1)*32 + j] }
    } else {
      for j : 0..32 { back2.bits[768 - (i - 8 + 1)*32 + j] }
    }
  };
  ShaState(a, e, w)
}

component ExtractBits(steps: Array<DoShaStep, 8>, i: Val) {
    [InRange(0, i, 8), InRange(8, i, 16), InRange(16, i, 24), InRange(24, i, 25)] ->
      (steps[i].w, steps[i - 8].a, steps[i - 16].e, for j : 0..32 {0})
}

component LoadWin(kf: Array<Val, 100>, round: Val, block: Val) {
  blockSelect := OneHot<4>(block);
  [1 - round, round] -> (
    blockSelect -> (
      for i : 0..8 { for j : 0..2 { kf[(i + 0) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { kf[(i + 16) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { kf[(i + 32) * 2 + j] }},
      [[kf[96], kf[97]], [kf[98], kf[99]], [0, 0], [0, 0],
       [0, 0], [0, 0], [0, 0], [0, 0]]
    ),
    blockSelect -> (
      for i : 0..8 { for j : 0..2 { kf[(i + 8) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { kf[(i + 24) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { kf[(i + 40) * 2 + j] }},
      for i : 0..8 { for j : 0..2 { 0 }}
    )
  )
}

component ShaCycle(back1: TopState, back2: TopState, round: Val, block: Val) {
  Log("ShaCycle", block, round);
  // Extract SHA state
  stateIn := LoadShaState(back1, back2);
  oneHot := OneHot<8>(round);
  isLoad := Reg(oneHot -> (1, 1, 0, 0, 0, 0, 0, 0));
  localK := GetK8(oneHot);
  win := LoadWin(back1.kflat, round, block);
  step0 := DoShaStep(stateIn, localK[0], isLoad, win[0]);
  step1 := DoShaStep(step0.newState, localK[1], isLoad, win[1]);
  step2 := DoShaStep(step1.newState, localK[2], isLoad, win[2]);
  step3 := DoShaStep(step2.newState, localK[3], isLoad, win[3]);
  step4 := DoShaStep(step3.newState, localK[4], isLoad, win[4]);
  step5 := DoShaStep(step4.newState, localK[5], isLoad, win[5]);
  step6 := DoShaStep(step5.newState, localK[6], isLoad, win[6]);
  step7 := DoShaStep(step6.newState, localK[7], isLoad, win[7]);
  steps := [step0, step1, step2, step3, step4, step5, step6, step7];
  bits := for x : 0..800 {
    j := x & 31;
    i := (x - j) / 32 + 0;
    ExtractBits(steps, i)[j]
  };
  topState := TopState(bits, back1.kflat, back1.sflat);
  for i : 0..8 {
    for j : 0..32 {
      AliasLayout!(steps[i].w[j], topState.bits[i*32 + j]);
      AliasLayout!(steps[i].a[j], topState.bits[256 + i*32 + j]);
      AliasLayout!(steps[i].e[j], topState.bits[512 + i*32 + j]);
    }
  };
  topState
}

extern IsFirstCycle(): Val;
extern GetPreimage(idx: Val): Val;
extern NextPreimage(): Val;

/*
- Init cycle (sets up)

- 1 Read cycle - Loads kflat, sets up SHA
- 8 * 4 sha cycles (mixes kflat + zeros into SHA state)
- 2 Expand cycles: Loads kflat into Keccak state
- 24 * 5 keccak cycles (mixes Keccak state)
- Write cycle - Takes keccak output -> kflat
- 8 * 4 sha cycles (mixes kflat + zeros into SHA state)
*/

component CycleTypeInit() { 0 }
component CycleTypeRead() { 1 }
component CycleTypeExpand() { 2 }
component CycleTypeWrite() { 3 }
component CycleTypeKeccakRound0() { 4 }
component CycleTypeKeccakRound1() { 5 }
component CycleTypeKeccakRound2() { 6 }
component CycleTypeKeccakRound3() { 7 }
component CycleTypeKeccakRound4() { 8 }
component CycleTypeSha() { 9 }
component CycleTypeShutdown() { 10 }

// TODO
component InitCycle() {
  Log("InitCycle");
  load := for i : 0..100 { 0 };
  bits := for i : 0..800 { 0 };
  sflat := for i : 0..16 { 0 };
  TopState(bits, load, sflat)
}

// TODO
component ReadCycle(stateIn: TopState) {
  Log("ReadCycle");
  load := for i : 0..100 { NondetReg(GetPreimage(i)) };
  bits := for i : 0..800 { 0 };  // TODO: load from sflat
  stateOut := TopState(bits, load, stateIn.sflat);
  for i : 0..100 {
    AliasLayout!(stateOut.kflat[i], load[i]);
  };
  stateOut
}

// TODO
component ExpandCycle(back1: TopState, back2: TopState, subType: Val) {
  Log("ExpandCycle");
  load := for i : 0..100 { 0 };
  bits := for i : 0..800 { 0 };
  sflat := for i : 0..16 { 0 };
  TopState(bits, load, sflat)
}

// TODO
component WriteCycle(stateIn: TopState) {
  Log("WriteCycle");
  load := for i : 0..100 { 0 };
  bits := for i : 0..800 { 0 };
  sflat := for i : 0..16 { 0 };
  TopState(bits, load, sflat)
}

// TODO
component ShutdownCycle(stateIn: TopState) {
  Log("ShutdownCycle");
  load := for i : 0..100 { 0 };
  bits := for i : 0..800 { 0 };
  sflat := for i : 0..16 { 0 };
  TopState(bits, load, sflat)
}

component ControlState(cycleType: Val, subType: Val, block: Val, round: Val) {
  cycleType := Reg(cycleType);
  subType := Reg(subType);
  block := Reg(block);
  round := Reg(round);
}

component KeccackNextRound(prev: ControlState) {
  isLast := IsZero(prev.round - 23);
  if (isLast) {
    ControlState(CycleTypeWrite(), 0, 0, 0)
  } else {
    ControlState(CycleTypeKeccakRound0(), 0, 0, prev.round + 1)
  }
}

component ShaNext(prev: ControlState) {
  /*
  // We have 1 of 5 exits:
  1) prev.round < 7, next round
  2) prev.round == 7, prev.block < 3, next block
  3) prev.round == 7, prev.block == 3, subType == 0, expand
  4) prev.round == 7, prev.block == 3, subType == 1, nondetDone() == 0, read
  4) prev.round == 7, prev.block == 3, subType == 1, nondetDone() == 1, shutdown
  */
  isLastRound := IsZero(prev.round - 7);
  isLastBlock := IsZero(prev.block - 3);
  doNextRound := 1 - isLastRound;
  doNextBlock := Reg(isLastRound * (1 - isLastBlock));
  doExpand := Reg(isLastRound * isLastBlock * (1 - prev.subType));
  doFinal := Reg(isLastRound * isLastBlock * prev.subType);
  [doNextRound, doNextBlock, doExpand, doFinal] -> (
    ControlState(CycleTypeSha(), prev.subType, prev.block, prev.round + 1),
    ControlState(CycleTypeSha(), prev.subType, prev.block + 1, 0),
    ControlState(CycleTypeExpand(), 0, 0, 0),
    {
      more := NondetReg(NextPreimage());
      AssertBit(more);
      if (more) {
        ControlState(CycleTypeRead(), 0, 0, 0)
      } else {
        ControlState(CycleTypeShutdown(), 0, 0, 0)
      }
   }
  )
}

component ComputeCurrentStep(prevMux: Array<Val, 11>, prev: ControlState) {
  prevMux -> (
    ControlState(CycleTypeRead(), 0, 0, 0),  // Init -> Read
    ControlState(CycleTypeSha(), 0, 0, 0),  // Read -> SHA:0
    if (prev.subType) {
      ControlState(CycleTypeKeccakRound0(), 0, 0, 0)  // Expand1 -> Round0
    } else {
      ControlState(CycleTypeExpand(), 1, 0, 0)  // Expand0 -> Expand1
    },
    ControlState(CycleTypeSha(), 1, 0, 0),  // Write -> SHA
    ControlState(CycleTypeKeccakRound1(), 0, 0, prev.round),
    ControlState(CycleTypeKeccakRound2(), 0, 0, prev.round),
    ControlState(CycleTypeKeccakRound3(), 0, 0, prev.round),
    ControlState(CycleTypeKeccakRound4(), 0, 0, prev.round),
    KeccackNextRound(prev),
    ShaNext(prev),
    ControlState(CycleTypeShutdown(), 0, 0, 0)
  )
}

// Annoyingly back directly on OneHot doesn't work
component WrapOneHot(oneHot: OneHot<11>) {
  for i : 0..11 { Reg(oneHot.bits[i]) }
}

component Top() {
  isFirst := NondetReg(IsFirstCycle());
  cycleMux : WrapOneHot;
  controlState : ControlState;
  controlState := if (isFirst) {
    ControlState(CycleTypeInit(), 0, 0, 0)
  } else {
    ComputeCurrentStep(cycleMux@1, controlState@1)
  };
  oneHot := OneHot<11>(controlState.cycleType);
  cycleMux := WrapOneHot(oneHot);
  for i : 0..11 {
    AliasLayout!(oneHot[i], cycleMux[i]);
  };
  curState: TopState;
  curState := cycleMux -> (
    InitCycle(),
    ReadCycle(curState@1),
    ExpandCycle(curState@1, curState@2, controlState.subType),
    WriteCycle(curState@1),
    KeccakRound0(curState@2, curState@1),
    KeccakRound12<0>(curState@1, curState@3, curState@2, curState@1),
    KeccakRound12<1>(curState@2, curState@4, curState@3, curState@1),
    KeccakRound34<0>(curState@2, curState@1, curState@1, controlState.round),
    KeccakRound34<1>(curState@3, curState@2, curState@1, controlState.round),
    ShaCycle(curState@1, curState@2, controlState.round, controlState.block),
    ShutdownCycle(curState@1)
  );
}
