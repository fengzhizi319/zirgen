

component NondetBitReg(x: Val) {
  reg := NondetReg(x);
  reg * (1 - reg) = 0;
  reg
}

component OneHot<N: Val>(v: Val) {
  // Make N bit registers, with bit v set and all others 0
  bits := for i : 0..N { NondetBitReg(Isz(i - v)) };
  // Verify exactly one bit is set
  reduce bits init 0 with Add = 1;
  // Verify the right bit is set
  reduce for i : 0..N { bits[i] * i } init 0 with Add = v;
  bits
}

component Xor5(vals: Array<Val, 5>) {
  tot := reduce vals init 0 with Add;
  out := NondetBitReg(tot & 1);
  diff := tot - out;
  diff * (2 - diff) * (4 - diff) = 0;
  out
}

component Xor(a: Val, b: Val) {
  a + b - 2 * a * b
}

component Theta(a: Array<Array<Array<Val, 64>, 5>, 5>) {
  c := for j : 0..5 {
    for k : 0..64 {
      Xor5(for i : 0..5 { a[i][j][k] } )
    }
  };
  d := for j : 0..5 { 
    for k : 0..64 {
      jm1 := if (Isz(j)) { 4 } else { j - 1 };
      jp1 := if (Isz(j-4)) { 0 } else { j + 1 };
      kp1 := if (Isz(k)) { 63 } else { k - 1 };
      Xor(c[jm1][k], c[jp1][kp1])
    }
  };
  for i : 0..5 {
    for j : 0..5 {
      for k : 0..64 {
        Xor(a[i][j][k], d[j][k])
      }
    }
  }
}

component RhoMatrix() {
  [[0,36,3,41,18],[1,44,10,45,2],[62,6,43,15,61],[28,55,25,21,56],[27,20,39,8,14]]
}


component RotateLeft(in: Array<Val, 64>, n: Val) {
  for k : 0..64 {
    if (InRange(0, k - n, 64)) { in[k - n] } else { in[64 + k - n] }
  }
}

component Rho(a: Array<Array<Array<Val, 64>, 5>, 5>) {
  for i : 0..5 {
    for j : 0..5 {
      RotateLeft(a[i][j], RhoMatrix()[j][i])
    }
  }
}

component PiMatrix() {
  [[0,3,1,4,2],[1,4,2,0,3],[2,0,3,1,4],[3,1,4,2,0],[4,2,0,3,1]]
}

component Pi(a: Array<Array<Array<Val, 64>, 5>, 5>) {
  for i : 0..5 {
    for j : 0..5 {
      newi := PiMatrix()[j][i];
      a[j][newi]
    }
  }
}

component Chi(a: Array<Array<Array<Val, 64>, 5>, 5>) {
  for i : 0..5 {
    for j : 0..5 {
      for k : 0..64 {
        jp1 := if (Isz(4-j)) { 0 } else { j + 1 };
        jp2 := if (Isz(4-jp1)) { 0 } else { jp1 + 1 };
        Xor(a[i][j][k], (1 - a[i][jp1][k]) * a[i][jp2][k])
      }
    }
  }
}

component IotaTable() {
 [
  [0x0001, 0x0000, 0x0000, 0x0000],
  [0x8082, 0x0000, 0x0000, 0x0000],
  [0x808a, 0x0000, 0x0000, 0x8000],
  [0x8000, 0x8000, 0x0000, 0x8000],
  [0x808b, 0x0000, 0x0000, 0x0000],
  [0x0001, 0x8000, 0x0000, 0x0000],
  [0x8081, 0x8000, 0x0000, 0x8000],
  [0x8009, 0x0000, 0x0000, 0x8000],
  [0x008a, 0x0000, 0x0000, 0x0000],
  [0x0088, 0x0000, 0x0000, 0x0000],
  [0x8009, 0x8000, 0x0000, 0x0000],
  [0x000a, 0x8000, 0x0000, 0x0000],
  [0x808b, 0x8000, 0x0000, 0x0000],
  [0x008b, 0x0000, 0x0000, 0x8000],
  [0x8089, 0x0000, 0x0000, 0x8000],
  [0x8003, 0x0000, 0x0000, 0x8000],
  [0x8002, 0x0000, 0x0000, 0x8000],
  [0x0080, 0x0000, 0x0000, 0x8000],
  [0x800a, 0x0000, 0x0000, 0x0000],
  [0x000a, 0x8000, 0x0000, 0x8000],
  [0x8081, 0x8000, 0x0000, 0x8000],
  [0x8080, 0x0000, 0x0000, 0x8000],
  [0x0001, 0x8000, 0x0000, 0x0000],
  [0x8008, 0x8000, 0x0000, 0x8000]
 ]
}

component ExpandedIotaTable() {
  for i : 0..24 { ExpandWord(IotaTable()[i]) }
}

component RoundToArray(idx: Val) {
  table := ExpandedIotaTable();
  split := OneHot<24>(idx);
  for k : 0..64 {
    reduce for i : 0..24 { split[i] * table[i][k] } init 0 with Add
  }
}

component Iota(a: Array<Array<Array<Val, 64>, 5>, 5>, round: Val) {
  iotaArray := RoundToArray(round);
  for i : 0..5 {
    for j : 0..5 {
      if (Isz(i) * Isz(j)) {
        for k: 0..64 { Xor(iotaArray[k], Reg(a[i][j][k])) }
      } else {
        a[i][j]
      }
    }
  }
}

component Registerize(a: Array<Array<Array<Val, 64>, 5>, 5>) {
  for i : 0..5 {
    for j : 0..5 {
      for k : 0..64 {
        Reg(a[i][j][k])
      }
    }
  }
}


component TestDoRound(a: Array<Array<Array<Val, 64>, 5>, 5>, round: Val) {
  a := Registerize(Pi(Rho(Theta(a))));
  Registerize(Iota(Chi(a), round))
}

component TestPermute(a: Array<Array<Array<Val, 64>, 5>, 5>) {
  reduce 0..4 init a with TestDoRound
}
  
component Po2(n: Val) {
  arr := [ 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 
           0x0100, 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000 ];
  arr[n]
}

component ContractWord(in: Array<Val, 64>) {
  for i : 0..4 {
    reduce for j : 0..16 { Po2(j) * in[i*16 + j] } init 0 with Add
  }
} 

component ExpandWord(in: Array<Val, 4>) {
  for n : 0..64 {
    j := n & 15;
    i := (n - j) * 1887436801;  // THis constant is 1/16: TODO fix compiler divide
    NondetBitReg((in[i] & Po2(j)) / Po2(j))
  }
}

component ExpandState(in: Array<Array<Array<Val, 4>, 5>, 5>) {
  for i : 0..5 {
    for j : 0..5 {
      ExpandWord(in[i][j])
    }
  }
}

component ContractState(in: Array<Array<Array<Val, 64>, 5>, 5>) {
  for i : 0..5 {
    for j : 0..5 {
      ContractWord(in[i][j])
    }
  }
}

component PrintState(in: Array<Array<Array<Val, 64>, 5>, 5>) {
  con := ContractState(in);
  for i : 0..5 {  
    for j : 0..5 {
      Log("%x, %x, %x, %x", con[i][j][0], con[i][j][1], con[i][j][2], con[i][j][3])
    }
  }
}

/*
test TestTheta {
  input := ExpandState(for i : 0..5 { for j : 0..5 { [ j, 0, i, 0] } });
  PrintState(input);
  Log("-----");
  output := Theta(input);
  PrintState(output);
}

test TestRho {
  input := ExpandState(for i : 0..5 { for j : 0..5 { [ j, 0, i, 0] } });
  PrintState(input);
  Log("-----");
  output := Rho(input);
  PrintState(output);
}

test TestPi {
  input := ExpandState(for i : 0..5 { for j : 0..5 { [ j, 0, i, 0] } });
  PrintState(input);
  Log("-----");
  output := Pi(input);
  PrintState(output);
}

test TestChi {
  input := ExpandState(for i : 0..5 { for j : 0..5 { [ j, 0, i, 0] } });
  PrintState(input);
  Log("-----");
  output := Chi(input);
  PrintState(output);
}

test TestIota {
  input := ExpandState(for i : 0..5 { for j : 0..5 { [ j, 0, i, 0] } });
  PrintState(input);
  Log("-----");
  output := Iota(input, 3);
  PrintState(output);
}
*/

test Permute {
  input := ExpandState(for i : 0..5 { for j : 0..5 { [ 0, 0, 0, 0] } });
  output := TestPermute(input);
  PrintState(output);
}

/*
test ExpandContract {
  testPatternSmall := [0x1234, 0x5555, 0xaaaa, 0xffff];
  testPatternBig := 
    [0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0,
     1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
     0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
  expanded := ExpandWord(testPatternSmall);
  for i : 0..64 {
    expanded[i] = testPatternBig[i];
  };
  contracted := ContractWord(testPatternBig);
  for i : 0..4 {
    contracted[i] = testPatternSmall[i];
  };
}
   
test Xor {
  Xor(0, 0) = 0;
  Xor(0, 1) = 1;
  Xor(1, 0) = 1;
  Xor(1, 1) = 0;
}

test Xor5 {
  Xor5([0, 0, 0, 0, 0]) = 0;
  Xor5([0, 0, 0, 0, 1]) = 1;
  Xor5([0, 0, 0, 1, 0]) = 1;
  Xor5([0, 0, 0, 1, 1]) = 0;
  Xor5([0, 0, 1, 0, 0]) = 1;
  Xor5([0, 0, 1, 0, 1]) = 0;
  Xor5([0, 0, 1, 1, 0]) = 0;
  Xor5([0, 0, 1, 1, 1]) = 1;
  Xor5([0, 1, 0, 0, 0]) = 1;
  Xor5([0, 1, 0, 0, 1]) = 0;
  Xor5([0, 1, 0, 1, 0]) = 0;
  Xor5([0, 1, 0, 1, 1]) = 1;
  Xor5([0, 1, 1, 0, 0]) = 0;
  Xor5([0, 1, 1, 0, 1]) = 1;
  Xor5([0, 1, 1, 1, 0]) = 1;
  Xor5([0, 1, 1, 1, 1]) = 0;
  Xor5([1, 0, 0, 0, 0]) = 1;
  Xor5([1, 0, 0, 0, 1]) = 0;
  Xor5([1, 0, 0, 1, 0]) = 0;
  Xor5([1, 0, 0, 1, 1]) = 1;
  Xor5([1, 0, 1, 0, 0]) = 0;
  Xor5([1, 0, 1, 0, 1]) = 1;
  Xor5([1, 0, 1, 1, 0]) = 1;
  Xor5([1, 0, 1, 1, 1]) = 0;
  Xor5([1, 1, 0, 0, 0]) = 0;
  Xor5([1, 1, 0, 0, 1]) = 1;
  Xor5([1, 1, 0, 1, 0]) = 1;
  Xor5([1, 1, 0, 1, 1]) = 0;
  Xor5([1, 1, 1, 0, 0]) = 1;
  Xor5([1, 1, 1, 0, 1]) = 0;
  Xor5([1, 1, 1, 1, 0]) = 0;
  Xor5([1, 1, 1, 1, 1]) = 1;
}

test HelloWorld {
  Log("Hello")
}
*/
