# The Keccak Accelerator

This directory contains the implementation of the keccak accelerator.

## Input transcript format

The expected format of the keccak input is a list of one or more of `data blocks` ending with a `final padding` consisting of 8 bytes of zeros (`0x0000000000000000`)

### Keccak Input Transcript

| Name          | Byte Length | Description                                                          |
|---------------|-------------|----------------------------------------------------------------------|
| data blocks   | arbitrary   | raw data blocks containing the block count followed by the raw data. |
| final padding |           8 | Padding used to indicate the end of the keccak input transcript.     |

### Data Blocks

Data blocks represent the raw data being hashed. This contains an 2-byte value that represents the block size followed by a sequence of bytes representing the raw data, ending with the output digest generated by running keccak.

| Name             | Byte Length | Description                                                                                 |
|------------------|-------------|---------------------------------------------------------------------------------------------|
| block count (BC) |          2  | the amount of blocks that the raw data spans. Each block is 136 bytes.                      |
| padding          |          6  | Padding containing all 0 values. This is used to align the length along an 8-byte boundary. |
| raw data         |   BC * 136  | Represents the raw data.                                                                    |
| output digest    |         32  | the keccak hash of the raw data.                                                            |

### Example: using the accelerator in Rust crates

Most rust cryptographic hashing crates use an API similar to the following code snippet:
```
let mut hasher = Keccak256::new();

// write input message
hasher.update(&input);

// read hash digest
let result = hasher.finalize();
```

In this code snippet, `hasher` carries an internal state which is modified the input using the `update(input)` function. `finalize` will generate a resulting hash. In order to use the accelerator we need to generate an input transcript. To keep the proof under 2 million cycles the maximum amount of data we can hash in the accelerator is approximately 95 kilobytes.

The following assumes a situation where a single call to finalize is compressing less than 95 KB of input data and only one instance of hasher is present.

* Every time update is called, the input is split up to fit inside the 136 byte block. Once the block fills up, it is compressed using keccak. In our design, we send each of the blocks to the host in order to record the raw data of the input transcript.
* Once the hasher's `finalize` function is called we can communicate with the termination so that the block count can be computed and for the keccak hash to be generated.
