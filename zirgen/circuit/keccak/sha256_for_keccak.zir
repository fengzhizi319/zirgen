import one_hot;

// use_once_mem_arg.zir
extern SimpleMemoryPoke(index: Val, data: Val);
extern SimpleMemoryPeek(index: Val) : Val;
component MEM_DIGEST_LEN() { 4 }
component MemDigest(elems: Array<Val, MEM_DIGEST_LEN()>) {
  elems
}
/*
component NondetDigestReg(elems: MemDigest) {
  elemRegs := for elem : elems { NondetReg(elem) };
  MemDigest(elemRegs)
}
*/
argument UseOnceMemoryElement(c: Val, i: Val, d: MemDigest) {
  count := NondetReg(c);
  index := NondetReg(i);
  //digest := NondetDigestReg(d);
  digest := [NondetReg(d[0]), NondetReg(d[1]), NondetReg(d[2]), NondetReg(d[3])];
}
component ReadMemory(i: Val) {
  digest := MemDigest(for elemIdx : 0..MEM_DIGEST_LEN() {
    SimpleMemoryPeek(i * MEM_DIGEST_LEN() + elemIdx)
  });
  elem := UseOnceMemoryElement(-1, i, digest);
  elem.digest
}
component WriteMemory(i: Val, d: MemDigest) {
  for elemIdx : 0..MEM_DIGEST_LEN() {
     SimpleMemoryPoke(i * MEM_DIGEST_LEN() + elemIdx, d[elemIdx]);
  };
  elem := UseOnceMemoryElement(1, i, d);
  elem.count = 1;
  elem.index = i;
  for elemIdx : 0..MEM_DIGEST_LEN() {
    elem.digest[elemIdx] = d[elemIdx];
  }
}
// EOF use_once_mem_arg.zir

// po2.zir unpacking up to 24 bits
component Po2(n: Val) {
  arr := [
    0x1,
    0x2,
    0x4,
    0x8,
    0x10,
    0x20,
    0x40,
    0x80,
    0x100,
    0x200,
    0x400,
    0x800,
    0x1000,
    0x2000,
    0x4000,
    0x8000,
    0x10000,
    0x20000,
    0x40000,
    0x80000,
    0x100000,
    0x200000,
    0x400000,
    0x800000
  ];
  arr[n]
}
component ToBits<n: Val>(x: Val) {
  for i : 0..n { NondetBitReg((x & Po2(i)) / Po2(i)) }
}
component FromBits<n: Val>(bits: Array<Val, n>) {
  reduce for i : 0..n { Po2(i) * bits[i] } init 0 with Add
}
// EOF po2.zir

// concatenate.zir
component Concatenate<T: Type, N: Val, M: Val>(a: Array<T, N>, b: Array<T, M>) {
  for i : 0..(N + M) {
    low := InRange(0, i, N);
    low*a[i] + (1-low)*b[i-N]
  }
}
component ConcatZeros<N: Val, M: Val>(a: Array<Val, N>) {
  for i : 0..(N + M) {
    low := InRange(0, i, N);
    low*a[i] + (1-low)*NondetReg(0)
  }
}
component ConcatElem<T: Type, N: Val>(a: Array<T, N>, b: T) {
  for i : 0..(N + 1) {
    low := InRange(0, i, N);
    low*a[i] + (1-low)*b
  }
}
// EOF concatenate.zir

component S2MAJOR_SETUP() { 17 }
component S2MAJOR_LOAD()  { 19 }
component S2MAJOR_MIX()   { 20 }

component S2MINOR_SKIP()   { 4 }
component S2MINOR_INIT()   { 0 }
component S2MINOR_FINI()   { 4 }
component S2MINOR_OUTPUT() { 8 }

// shared_keccak
component BLEN() { 22 }
component dummyB() { for i : 0.. BLEN() { 0 } }

component RetTuple(a: Array<Val, BLEN()>,
                   b: Array<Val, BLEN()>,
                   c: Array<Val, BLEN()>,
                   d: Array<Val, RLEN()>,
                   e: Array<Val, BLEN()>,
                   f: Array<Val, BLEN()>,
                   minor_count: Val,
                   major_count: Val,
                   round: Val,
                   block: Val,
                   memIdx: Val) {
  arr_a := for elem : a { Reg(elem) };
  arr_b := for elem : b { Reg(elem) };
  arr_c := for elem : c { Reg(elem) };
  arr_d := for elem : d { Reg(elem) };
  arr_e := for elem : e { Reg(elem) };
  arr_f := for elem : f { Reg(elem) };
  minor := Reg(minor_count);
  major := Reg(major_count);
  rnd := Reg(round);
  blk := Reg(block);
  midx := Reg(memIdx);
}

component s2a(rtuple: RetTuple) {
  a1 := rtuple.arr_a;
  a2 := for i : 0..10 { rtuple.arr_b[i] };
  Concatenate<Val,22,10>(a1, a2)
}
component s2e(rtuple: RetTuple) {
  e1 := for i : 10..22 { rtuple.arr_b[i] };
  e2 := for i : 0..20 { rtuple.arr_c[i] };
  Concatenate<Val,12,20>(e1, e2)
}
component s2w(rtuple: RetTuple) {
  w1 := rtuple.arr_e;
  w2 := for i : 0..10 { rtuple.arr_f[i] };
  Concatenate<Val,22,10>(w1, w2)
}
component s2aew(a_: Array<Val, 32>, e_: Array<Val, 32>, w_: Array<Val, 32>) {
  a := for i : 0..22 { a_[i] };
  b := Concatenate<Val,10,12>(for i : 22..32 { a_[i] }, for i : 0..12 { e_[i] });
  c := ConcatZeros<20,2>(for i : 12..32 { e_[i] });
  e := for i : 0..22 { w_[i] };
  f := ConcatZeros<10,12>(for i : 22..32 { w_[i] });
}
// EOF shared_keccak

component dummy32() { for i : 0..32 { 0 } }
component dummy24() { for i : 0..24 { 0 } }

component IVvals(i: Val) {
  arr := [[0x6a09, 0xe667],
          [0xbb67, 0xae85],
          [0x3c6e, 0xf372],
          [0xa54f, 0xf53a],
          [0x510e, 0x527f],
          [0x9b05, 0x688c],
          [0x1f83, 0xd9ab],
          [0x5be0, 0xcd19]];
  TwoShorts(arr[i][1],arr[i][0])
}

component sha256rc_table<i: Val>() {
  arr := [[0x428a,0x2f98],[0x7137,0x4491],[0xb5c0,0xfbcf],[0xe9b5,0xdba5],
          [0x3956,0xc25b],[0x59f1,0x11f1],[0x923f,0x82a4],[0xab1c,0x5ed5],
          [0xd807,0xaa98],[0x1283,0x5b01],[0x2431,0x85be],[0x550c,0x7dc3],
          [0x72be,0x5d74],[0x80de,0xb1fe],[0x9bdc,0x06a7],[0xc19b,0xf174],
          [0xe49b,0x69c1],[0xefbe,0x4786],[0x0fc1,0x9dc6],[0x240c,0xa1cc],
          [0x2de9,0x2c6f],[0x4a74,0x84aa],[0x5cb0,0xa9dc],[0x76f9,0x88da],
          [0x983e,0x5152],[0xa831,0xc66d],[0xb003,0x27c8],[0xbf59,0x7fc7],
          [0xc6e0,0x0bf3],[0xd5a7,0x9147],[0x06ca,0x6351],[0x1429,0x2967],
          [0x27b7,0x0a85],[0x2e1b,0x2138],[0x4d2c,0x6dfc],[0x5338,0x0d13],
          [0x650a,0x7354],[0x766a,0x0abb],[0x81c2,0xc92e],[0x9272,0x2c85],
          [0xa2bf,0xe8a1],[0xa81a,0x664b],[0xc24b,0x8b70],[0xc76c,0x51a3],
          [0xd192,0xe819],[0xd699,0x0624],[0xf40e,0x3585],[0x106a,0xa070],
          [0x19a4,0xc116],[0x1e37,0x6c08],[0x2748,0x774c],[0x34b0,0xbcb5],
          [0x391c,0x0cb3],[0x4ed8,0xaa4a],[0x5b9c,0xca4f],[0x682e,0x6ff3],
          [0x748f,0x82ee],[0x78a5,0x636f],[0x84c8,0x7814],[0x8cc7,0x0208],
          [0x90be,0xfffa],[0xa450,0x6ceb],[0xbef9,0xa3f7],[0xc671,0x78f2]];
  TwoShorts(arr[i][1],arr[i][0])
}

component TwoShorts(lsbs: Val, msbs: Val) {
  low := lsbs;
  high := msbs;
}

component rightRotate<T: Type, A: Val, N: Val>(a: Array<T, A>) {
  for i : 0..A {
    wraparound := InRange(0,i,A-N);
    wraparound*a[i+N] + (1-wraparound)*a[i+N-A]
  }
}

component rightShift<T: Type, A: Val, N: Val>(a: Array<T, A>) {
  for i : 0..A {
    wraparound := InRange(0,i,A-N);
    wraparound*a[i+N] + 0
  }
}

component xor3a<T: Type, N: Val>(x: Array<T, N>,
                                y: Array<T, N>, z: Array<T, N>) {
  for i : 0..N {
    ( (x[i]*y[i] + (1-x[i])*(1-y[i])) * z[i] ) +
    ( (1-(x[i]*y[i] + (1-x[i])*(1-y[i]))) * (1-z[i]) ) }
}

component maj3<T: Type, N: Val>(x: Array<T, N>,
                                y: Array<T, N>, z: Array<T, N>) {
  for i : 0..N
    { x[i]*y[i]*(1-z[i]) +
      x[i]*(1-y[i])*z[i] +
      (1-x[i])*y[i]*z[i] + x[i]*y[i]*z[i] }
}

component ch<T: Type, N: Val>(x: Array<T, N>,
                              y: Array<T, N>, z: Array<T, N>) {
  for i : 0..N { x[i]*y[i] + (1-x[i])*z[i] }
}

component pack2(arr: Array<Val, 32>) {
  low := Reg(FromBits<16>(for i : 0..16 { arr[i] }));
  high := Reg(FromBits<16>(for i : 16..32 { arr[i] }));
  TwoShorts(low, high)
}

component add(a: TwoShorts, b: TwoShorts) {
  TwoShorts(a.low + b.low, a.high + b.high)
}

component computeW(w_2: Array<Val, 32>, w_7: Array<Val, 32>,
                   w_15: Array<Val, 32>, w_16: Array<Val, 32>) {
  s0 := xor3a<Val,32>(rightRotate<Val,32,7>(w_15),
             rightRotate<Val,32,18>(w_15), rightShift<Val,32,3>(w_15));
  s1 := xor3a<Val,32>(rightRotate<Val,32,17>(w_2),
             rightRotate<Val,32,19>(w_2), rightShift<Val,32,10>(w_2));
  pack_s0 := pack2(s0);
  pack_s1 := pack2(s1);
  add(pack2(w_16), add(pack_s0, add(pack2(w_7), pack_s1)))
}

component computeAE(a_: Array<Val, 32>, b_: Array<Val, 32>, c_: Array<Val, 32>,
                    d_: Array<Val, 32>, e_: Array<Val, 32>, f_: Array<Val, 32>,
                    g_: Array<Val, 32>, h_: Array<Val, 32>,
                    w_: Array<Val, 32>, k_rc: TwoShorts) {
  s0 := xor3a<Val,32>(rightRotate<Val,32,2>(a_),
             rightRotate<Val,32,13>(a_), rightRotate<Val,32,22>(a_));
  s1 := xor3a<Val,32>(rightRotate<Val,32,6>(e_),
             rightRotate<Val,32,11>(e_), rightRotate<Val,32,25>(e_));
  pack_ch := pack2(ch<Val,32>(e_, f_, g_));
  stage1 := add(pack2(w_), add(k_rc, add(pack2(h_), add(pack_ch, pack2(s1)))));
  pack_maj := pack2(maj3<Val,32>(a_, b_, c_));
  aOut := add(stage1, add(pack_maj, pack2(s0)));
  eOut := add(stage1, pack2(d_));
}

component unpack_with_carry(low: Val, high: Val) {
  low_bits := ToBits<19>(low);
  FromBits<19>(low_bits) = low;
  carry := low_bits[16] + 2*low_bits[17] + 4*low_bits[18];
  high_plus_carry := high + carry;
  high_bits := ToBits<20>(high_plus_carry);
  FromBits<20>(high_bits) = high_plus_carry;
  low16 := for i : 0..16 { low_bits[i] };
  high16 := for i : 0..16 { high_bits[i] };
  Concatenate<NondetReg,16,16>(low16, high16)
}

component sha256load<I: Val>(rvprev01: RetTuple, rvprev02: RetTuple,
                             rvprev03: RetTuple, rvprev04: RetTuple) {
  idx := rvprev01.blk;
  end := rvprev01.midx + 1 - idx;
  invEnd := NondetReg(Inv(end));
  prod := Reg(end*invEnd);
  end*(1-prod) = 0;
  vals := [1-prod, prod] -> (
    [0,0,0,0,0,idx],
    { flag := rvprev01.rnd;
      [1-flag, flag] -> (
        { mem := ReadMemory(idx);
          [mem[0],mem[1],mem[2],mem[3],1,idx]
        },
        [rvprev01.arr_d[0],rvprev01.arr_d[1],0,0,0,idx+1])});
  inp1 := vals[0];
  high_w := ToBits<16>(inp1); //big endian
  inp2 := vals[1];
  low_w := ToBits<16>(inp2);
  unpacked_w := Concatenate<NondetReg,16,16>(low_w, high_w);
  ae := computeAE(s2a(rvprev01), s2a(rvprev02), s2a(rvprev03), s2a(rvprev04),
                  s2e(rvprev01), s2e(rvprev02), s2e(rvprev03), s2e(rvprev04),
                  unpacked_w, sha256rc_table<I>());
  new_a := unpack_with_carry(ae.aOut.low, ae.aOut.high);
  new_e := unpack_with_carry(ae.eOut.low, ae.eOut.high);
  Z := Isz(I-15);
  aew := s2aew(new_a, new_e, unpacked_w);
  new_d := [vals[2],vals[3],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
  [1-Z, Z] -> (
    RetTuple(aew.a, aew.b, aew.c, new_d, aew.e, aew.f,
             I+1, S2MAJOR_LOAD(), vals[4], vals[5], rvprev01.midx),
    RetTuple(aew.a, aew.b, aew.c, new_d, aew.e, aew.f,
             0, S2MAJOR_MIX(), vals[4], vals[5], rvprev01.midx))
}

component sha256load_all(rvprev01: RetTuple, rvprev02: RetTuple,
                         rvprev03: RetTuple, rvprev04: RetTuple) {
  minor_onehot := OneHot<16>(rvprev01.minor);
  minor_onehot -> (
    sha256load<0>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<1>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<2>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<3>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<4>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<5>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<6>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<7>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<8>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<9>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<10>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<11>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<12>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<13>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<14>(rvprev01, rvprev02, rvprev03, rvprev04),
    sha256load<15>(rvprev01, rvprev02, rvprev03, rvprev04)
  )
}

component sha256mix<S: Val, I: Val>(rvprev01: RetTuple, rvprev02: RetTuple,
                                    rvprev03: RetTuple, rvprev04: RetTuple,
                                    rvprev07: RetTuple, rvprev15: RetTuple,
                                    rvprev16: RetTuple) {
  packed_w := computeW(s2w(rvprev02), s2w(rvprev07), s2w(rvprev15), s2w(rvprev16));
  new_w := unpack_with_carry(packed_w.low, packed_w.high);
  ae := computeAE(s2a(rvprev01), s2a(rvprev02), s2a(rvprev03), s2a(rvprev04),
                  s2e(rvprev01), s2e(rvprev02), s2e(rvprev03), s2e(rvprev04),
                  new_w, sha256rc_table<(S+1)*16+I>());
  new_a := unpack_with_carry(ae.aOut.low, ae.aOut.high);
  new_e := unpack_with_carry(ae.eOut.low, ae.eOut.high);
  aew := s2aew(new_a, new_e, new_w);
  Z := Isz(I-15);
  [1-Z, Z] -> (
    RetTuple(aew.a, aew.b, aew.c, dummy24(), aew.e, aew.f,
             I+1, S2MAJOR_MIX()+S, 0, rvprev01.blk, rvprev01.midx),
    { F := Isz(S-2);
      [1-F, F] -> (
        RetTuple(aew.a, aew.b, aew.c, rvprev01.arr_d, aew.e, aew.f,
                 0, S2MAJOR_MIX()+S+1,
                 rvprev01.rnd, rvprev01.blk, rvprev01.midx),
        RetTuple(aew.a, aew.b, aew.c, rvprev01.arr_d, aew.e, aew.f,
                 S2MINOR_SKIP()+S2MINOR_FINI(), S2MAJOR_SETUP(),
                 rvprev01.rnd, rvprev01.blk, rvprev01.midx))
    })
}

component sha256mix_all<S: Val>(rvprev01: RetTuple, rvprev02: RetTuple,
                                rvprev03: RetTuple, rvprev04: RetTuple,
                                rvprev07: RetTuple, rvprev15: RetTuple,
                                rvprev16: RetTuple) {
  minor_onehot := OneHot<16>(rvprev01.minor);
  minor_onehot -> (
    sha256mix<S,0>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,1>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,2>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,3>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,4>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,5>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,6>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,7>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,8>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,9>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,10>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,11>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,12>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,13>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,14>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16),
    sha256mix<S,15>(rvprev01,rvprev02,rvprev03,rvprev04,rvprev07,rvprev15,rvprev16)
  )
}

component sha256init<I: Val>(rvprev01: RetTuple) {
  packed_a := IVvals(4-I);
  low_a := ToBits<16>(packed_a.low);
  high_a := ToBits<16>(packed_a.high);
  unpacked_a := Concatenate<NondetReg,16,16>(low_a, high_a);
  packed_e := IVvals(8-I);
  low_e := ToBits<16>(packed_e.low);
  high_e := ToBits<16>(packed_e.high);
  unpacked_e := Concatenate<NondetReg,16,16>(low_e, high_e);
  aew := s2aew(unpacked_a, unpacked_e, dummy32());
  Z := Isz(4-I);
  [1-Z, Z] -> (
    RetTuple(aew.a, aew.b, aew.c, dummy24(), dummyB(), dummyB(),
             S2MINOR_SKIP()+I, S2MAJOR_SETUP(), 0, 0, rvprev01.midx),
    RetTuple(aew.a, aew.b, aew.c, dummy24(), dummyB(), dummyB(),
             0, S2MAJOR_LOAD(), 0, 0, rvprev01.midx))
}

component sha256fini<I: Val>(rvprev01: RetTuple, rvprev02: RetTuple,
                             rvprev03: RetTuple, rvprev04: RetTuple,
                             rvprev68: RetTuple) {
  packed_a := add(pack2(s2a(rvprev04)), pack2(s2a(rvprev68)));
  new_a := unpack_with_carry(packed_a.low, packed_a.high);
  packed_e := add(pack2(s2e(rvprev04)), pack2(s2e(rvprev68)));
  new_e := unpack_with_carry(packed_e.low, packed_e.high);
  aew := s2aew(new_a, new_e, dummy32());

  Z := Isz(8-I);
  [1-Z, Z] -> (
    RetTuple(aew.a, aew.b, aew.c, rvprev01.arr_d, dummyB(), dummyB(),
             S2MINOR_SKIP()+I, S2MAJOR_SETUP(),
             rvprev01.rnd, rvprev01.blk, rvprev01.midx),
    { moreInput := rvprev01.midx + 1 - rvprev01.blk;
      invMoreInput := NondetReg(Inv(moreInput));
      prod := moreInput*invMoreInput;
      moreInput*(1-prod) = 0;
      [prod, 1-prod] -> (
        RetTuple(aew.a, aew.b, aew.c, rvprev01.arr_d, dummyB(), dummyB(),
                 0, S2MAJOR_LOAD(), rvprev01.rnd, rvprev01.blk, rvprev01.midx),
        { fa := pack2(new_a);
          fb := pack2(s2a(rvprev01));
          fc := pack2(s2a(rvprev02));
          fd := pack2(s2a(rvprev03));
          fe := pack2(new_e);
          ff := pack2(s2e(rvprev01));
          fg := pack2(s2e(rvprev02));
          fh := pack2(s2e(rvprev03));
          result := [fa.high,fa.low,fb.high,fb.low,fc.high,fc.low,fd.high,fd.low,
                     fe.high,fe.low,ff.high,ff.low,fg.high,fg.low,fh.high,fh.low,
                     0,0,0,0,0,0];
          RetTuple(result, dummyB(), dummyB(), dummy24(), dummyB(), dummyB(),
                   S2MINOR_SKIP()+S2MINOR_OUTPUT(), S2MAJOR_SETUP(),
                   0, 0, rvprev01.midx)
        })})
}
