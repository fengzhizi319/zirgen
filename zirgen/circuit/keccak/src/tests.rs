// Copyright 2024 RISC Zero, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::{cell::RefCell, collections::VecDeque, rc::Rc};

use anyhow::Result;
use hex::FromHex;
use hex_literal::hex;
use risc0_binfmt::read_sha_halfs;
use risc0_circuit_keccak_test_methods::{KECCAK_ELF, KECCAK_ID};
use risc0_core::field::baby_bear::BabyBearElem;
use risc0_zkp::core::digest::{Digest, DIGEST_SHORTS};
use risc0_zkvm::{
    get_prover_server, ExecutorEnv, KeccakCoprocessorCallback, ProveKeccakRequest,
    ProveKeccakResponse, ProveZkrRequest, ProverOpts,
};
use test_log::test;

use crate::prove::keccak_prover;

#[derive(Default)]
struct Coprocessor;

impl KeccakCoprocessorCallback for Coprocessor {
    fn prove_keccak(&mut self, req: ProveKeccakRequest) -> Result<ProveKeccakResponse> {
        let input_u32s: &[u32] = bytemuck::cast_slice(req.input.as_slice());
        let input: VecDeque<u32> = Vec::from(input_u32s).into();
        let prover = keccak_prover()?;
        let control_root: Digest = *crate::get_control_root(req.po2);
        let seal = prover.prove(input, req.po2)?;
        let claim_digest: Digest = read_sha_halfs(&mut VecDeque::from_iter(
            bytemuck::checked::cast_slice::<_, BabyBearElem>(&seal[0..DIGEST_SHORTS])
                .iter()
                .copied()
                .map(u32::from),
        ))?;

        // Make sure we have a valid seal so we can fail early if anything went wrong
        prover.verify(&seal).expect("Verification failed");

        let claim_sha_input = claim_digest
            .as_words()
            .iter()
            .copied()
            .flat_map(|x| [x & 0xffff, x >> 16])
            .map(BabyBearElem::new)
            .collect::<Vec<_>>();

        let mut zkr_input: Vec<u32> = Vec::new();
        zkr_input.extend(control_root.as_words());
        zkr_input.extend(seal);
        zkr_input.extend(bytemuck::cast_slice(claim_sha_input.as_slice()));

        // Lift to recursion circuit
        let zkr_lift = ProveZkrRequest {
            control_id: *crate::get_control_id(req.po2),
            claim_digest,
            input: bytemuck::cast_slice(zkr_input.as_slice()).into(),
        };

        Ok(ProveKeccakResponse { zkr_lift })
    }
}

fn run_test(claim_digest: Digest, input: &[u8], po2: usize) -> Result<()> {
    let input: Vec<u32> = input
        .chunks_exact(4)
        .map(|chunk| u32::from_le_bytes(chunk.try_into().unwrap()))
        .collect();
    let to_guest: (Digest, Vec<u32>, usize) = (claim_digest, input, po2);

    let coprocessor = Rc::new(RefCell::new(Coprocessor::default()));

    let env = ExecutorEnv::builder()
        .keccak_coprocessor_callback_ref(coprocessor.clone())
        .write(&to_guest)?
        .build()?;

    crate::prove::zkr::register_zkrs();

    let prover = get_prover_server(&ProverOpts::fast())?;

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, KECCAK_ELF)?.receipt;

    // Make sure this receipt actually depends on the assumption;
    // otherwise this test might give a false negative.
    assert!(!receipt
        .inner
        .composite()
        .unwrap()
        .assumption_receipts
        .is_empty());

    // Make sure the receipt verifies OK
    receipt.verify(KECCAK_ID)?;

    Ok(())
}

#[test]
fn test_keccak_0() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("76c318d26fa4501763d1a20edcf97a0bcac1a6e16a0a9b2523101a7c63a8a832")?,
        &hex!("010000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a4700000000000000000"),
        /*po2=*/ 14,
    )?;
    Ok(())
}

#[test]
fn test_keccak_0s() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("dad72c8721197471cf4dda9291a153f69f4cbe10c80a907e16f3756bc597a0cc")?,
        &hex!("010000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a0000000000000000"),
        /*po2=*/ 14,
    )?;
    Ok(())
}

#[test]
fn test_keccak_1k() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("b39574638e980a6e7cec17b3fd54474809b09293fcda5947573f6678268a23c7")?,
        &hex!("010000000000000054686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F672E0100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080578951e24efd62a3d63a86f7cd19aaa53c898fe287d2552133220370240b572d0000000000000000"),
        /*po2=*/ 14,
    )?;
    Ok(())
}

#[test]
fn test_keccak_1s() -> Result<()> {
    run_test(
        /*claim=*/
// CHECK: sha256output: 0x56e6,0xb26d 0x9be,0x1343 0xb698,0xebe5 0x4dd,0xb185 0x60dd,0x3168 0x8a01,0x1555 0x3bab,0xfdff 0xf3a2,0xe0db
        Digest::from_hex("56e6b26d09be1343b698ebe504ddb18560dd31688a0115553babfdfff3a2e0db")?,
        &hex!("010000000000000054686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F672E0600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000080a80f839cd4f83f6c3dafc87feae470045e4eb0d366397d5c6ce34ba1739f734d0000000000000000"),
        /*po2=*/ 14,
    )?;
    Ok(())
}

#[test]
fn test_keccak_2k() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("420e6b2cc4cd396ecf6b7e4c8b4c1c1e88c3589534b581fd133793a6e53006f1")?,
        &hex!("0600000000000000436F6D6D616E64657220526F64657269636B20426C61696E65206C6F6F6B6564206672616E746963616C6C792061726F756E6420746865206272696467652E20776865726520686973206F66666963657273207765726520646972656374696E6720726570616972732077697468206C6F7720616E6420757267656E7420766F696365732C2073757267656F6E7320617373697374696E67206174206120646966666963756C74206F7065726174696F6E2E20546865206772617920737465656C20636F6D706172746D656E7420776173206120636F6E667573696F6E206F6620616374697669746965732C2065616368206F726465726C7920627920697473656C662062757420746865206F766572616C6C20696D7072657373696F6E20776173206F66206368616F732E2053637265656E732061626F7665206F6E652068656C6D736D616E27732073746174696F6E2073686F7765642074686520706C616E65742062656C6F7720616E6420746865206F746865722C20736869707320696E206F72626974206E656172204D61634172746875722C20627574206576657279776865726520656C7365207468652070616E656C20636F7665727320686164206265656E2072656D6F7665642066726F6D20636F6E736F6C65732C207465737420696E737472756D656E7473207765726520636C697070656420696E746F20746865697220696E73696465732C20616E6420746563686E696369616E732073746F6F64206279207769746820636F6C6F722D636F64656420656C656374726F6E696320617373656D626C69657320746F207265706C6163652065766572797468696E672074686174207365656D656420646F75627466756C2E205468756D707320616E64207768696E657320736F756E646564207468726F75676820746865207368697020383920736F6D657768657265206166742074686520656E67696E656572696E67206372657720776F726B6564206F6E207468652068756C6C2E01000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008028c3f5c69c21be780e5508d355ebf7d5e060f203ca8717447b71cb44544df5c70200000000000000546865736520776F7264732077657265207574746572656420696E204A756C79203138303520627920416E6E61205061766C6F766E6120536368657265722C20612064697374696E67756973686564206C616479206F662074686520636F7572742C20616E6420636F6E666964656E7469616C206D6169642D6F662D686F6E6F757220746F2074686520456D7072657373204D617279612046796F646F726F766E612E2049742077617320686572206772656574696E6720746F205072696E63652056617373696C792C2061206D616E206869676820696E2072616E6B20616E64206F66666963652C2077686F207761732074686520666972737420746F2061727269766520617401000000000000804bdc1874a3125f1f911fe8c76ac8443a6ec623ef91bc58eabf54c5762097894d0000000000000000"),
        /*po2=*/ 15,
    )?;
    Ok(())
}

#[test]
fn test_keccak_2s() -> Result<()> {
    run_test(
        /*claim=*/
        Digest::from_hex("197759ac2680d214b9046eddaa4bd1b1354da6d6b97b73ea539d1b80db0b8f76")?,
        &hex!("0600000000000000436F6D6D616E64657220526F64657269636B20426C61696E65206C6F6F6B6564206672616E746963616C6C792061726F756E6420746865206272696467652E20776865726520686973206F66666963657273207765726520646972656374696E6720726570616972732077697468206C6F7720616E6420757267656E7420766F696365732C2073757267656F6E7320617373697374696E67206174206120646966666963756C74206F7065726174696F6E2E20546865206772617920737465656C20636F6D706172746D656E7420776173206120636F6E667573696F6E206F6620616374697669746965732C2065616368206F726465726C7920627920697473656C662062757420746865206F766572616C6C20696D7072657373696F6E20776173206F66206368616F732E2053637265656E732061626F7665206F6E652068656C6D736D616E27732073746174696F6E2073686F7765642074686520706C616E65742062656C6F7720616E6420746865206F746865722C20736869707320696E206F72626974206E656172204D61634172746875722C20627574206576657279776865726520656C7365207468652070616E656C20636F7665727320686164206265656E2072656D6F7665642066726F6D20636F6E736F6C65732C207465737420696E737472756D656E7473207765726520636C697070656420696E746F20746865697220696E73696465732C20616E6420746563686E696369616E732073746F6F64206279207769746820636F6C6F722D636F64656420656C656374726F6E696320617373656D626C69657320746F207265706C6163652065766572797468696E672074686174207365656D656420646F75627466756C2E205468756D707320616E64207768696E657320736F756E646564207468726F75676820746865207368697020383920736F6D657768657265206166742074686520656E67696E656572696E67206372657720776F726B6564206F6E207468652068756C6C2E0600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000805db9add409333e7f0834569e8e0f6825d684a88363d398b1d0ead06e01d03c1e0200000000000000546865736520776F7264732077657265207574746572656420696E204A756C79203138303520627920416E6E61205061766C6F766E6120536368657265722C20612064697374696E67756973686564206C616479206F662074686520636F7572742C20616E6420636F6E666964656E7469616C206D6169642D6F662D686F6E6F757220746F2074686520456D7072657373204D617279612046796F646F726F766E612E2049742077617320686572206772656574696E6720746F205072696E63652056617373696C792C2061206D616E206869676820696E2072616E6B20616E64206F66666963652C2077686F207761732074686520666972737420746F20617272697665206174060000000000008076d8ddb3fc6c9825ed4a81157c3486e4f35df5cdcf93df3b5c80f1d93ec144fb0000000000000000"),
        /*po2=*/ 15,
    )?;
    Ok(())
}
